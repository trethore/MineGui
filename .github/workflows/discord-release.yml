name: Notify Discord on New Package Version

on:
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch:

permissions:
  contents: write
  packages: read

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Install cloc
        run: |
          sudo apt-get update
          sudo apt-get install -y cloc

      - name: Get latest package version
        id: latest
        env:
          REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PACKAGE_NAME: tytoo.minegui.minegui
          PACKAGE_TYPE: maven
        run: |
          owner=${REPO%%/*}
          repo=${REPO#*/}
          encoded_package=$(python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=""))' "$PACKAGE_NAME")
          base_url="https://api.github.com"

          fetch_versions() {
            local path=$1
            curl -s -w "\n%{http_code}" \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "${base_url}/${path}"
          }

          endpoint="users/${owner}/packages/${PACKAGE_TYPE}/${encoded_package}/versions?per_page=1"
          response=$(fetch_versions "$endpoint")
          body=$(printf '%s' "$response" | head -n -1)
          status=$(printf '%s' "$response" | tail -n1)

          if [ "$status" -eq 404 ]; then
            endpoint="orgs/${owner}/packages/${PACKAGE_TYPE}/${encoded_package}/versions?per_page=1"
            response=$(fetch_versions "$endpoint")
            body=$(printf '%s' "$response" | head -n -1)
            status=$(printf '%s' "$response" | tail -n1)
          fi

          if [ "$status" -eq 404 ]; then
            endpoint="repos/${owner}/${repo}/packages/${PACKAGE_TYPE}/${encoded_package}/versions?per_page=1"
            response=$(fetch_versions "$endpoint")
            body=$(printf '%s' "$response" | head -n -1)
            status=$(printf '%s' "$response" | tail -n1)
          fi

          if [ "$status" -lt 200 ] || [ "$status" -ge 300 ]; then
            echo "Failed to fetch package versions (HTTP ${status})"
            printf '%s\n' "$body"
            exit 1
          fi

          tag=$(printf '%s' "$body" | jq -r 'if type=="array" and length>0 then .[0].name // empty else empty end')
          if [ -z "$tag" ]; then
            echo "No package version found"
            printf '%s\n' "$body"
            exit 1
          fi
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Read last notified version
        id: last
        run: |
          if [ -f ".github/last_notified_version" ]; then
            value=$(cat .github/last_notified_version)
          else
            value=""
          fi
          echo "value=$value" >> "$GITHUB_OUTPUT"

      - name: Check if new version
        id: check
        run: |
          if [ "${{ steps.last.outputs.value }}" = "${{ steps.latest.outputs.tag }}" ]; then
            echo "new=false" >> "$GITHUB_OUTPUT"
          else
            echo "new=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate Discord payload
        if: steps.check.outputs.new == 'true'
        id: payload
        env:
          TAG: ${{ steps.latest.outputs.tag }}
        run: |
          if [ -x "./gradlew" ]; then
            deps=$(./gradlew dependencies --configuration compileClasspath --console=plain -q || ./gradlew dependencies --console=plain -q || true)
          else
            deps=""
          fi

          deps_snippet=$(printf '%s\n' "$deps" | sed -n '1,40p')

          if command -v cloc >/dev/null 2>&1; then
            cloc_output=$(cloc src/client/ --quiet || true)
          else
            cloc_output=""
          fi

          summary=$(printf '%s\n' "$cloc_output" | awk '$1=="SUM:" {print $0}')
          cloc_snippet=$(printf '%s\n' "$cloc_output" | sed -n '1,20p')

          if [ -n "$summary" ]; then
            files=$(awk '{print $2}' <<< "$summary")
            blank=$(awk '{print $3}' <<< "$summary")
            comment=$(awk '{print $4}' <<< "$summary")
            code=$(awk '{print $5}' <<< "$summary")
          else
            files=0
            blank=0
            comment=0
            code=0
          fi

          if [ -z "$cloc_snippet" ]; then
            cloc_snippet="cloc introuvable ou échec de l'analyse"
          fi

          description="**Nouvelle version détectée:** ${TAG}\n\n**Dependencies (extrait)**\n\`\`\`txt\n${deps_snippet}\n\`\`\`\n**Code metrics (src/client)**\n\`\`\`txt\n${cloc_snippet}\n\`\`\`\nFichiers: ${files} | Lignes de code: ${code} | Blancs: ${blank} | Commentaires: ${comment}"

          description_json=$(printf '%s' "$description" | python3 -c 'import json, sys; print(json.dumps(sys.stdin.read()))')

          jq -n --argjson desc "$description_json" '{
            "embeds": [
              {
                "title": "New package version published",
                "description": $desc,
                "color": 5814783
              }
            ]
          }' > payload.json

      - name: Send Discord notification
        if: steps.check.outputs.new == 'true'
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -z "$DISCORD_WEBHOOK_URL" ]; then
            echo "Error: DISCORD_WEBHOOK_URL secret not set"
            exit 1
          fi

          RESPONSE=$(curl -s -w "\n%{http_code}" -H "Content-Type: application/json" -X POST -d @payload.json "$DISCORD_WEBHOOK_URL")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "Successfully sent Discord notification (HTTP ${HTTP_CODE})"
          else
            echo "Error: Discord webhook failed with HTTP ${HTTP_CODE}"
            echo "Response: $(echo "$RESPONSE" | head -n-1)"
            exit 1
          fi

      - name: Save last notified version
        if: steps.check.outputs.new == 'true'
        env:
          TAG: ${{ steps.latest.outputs.tag }}
        run: |
          mkdir -p .github
          echo "$TAG" > .github/last_notified_version
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .github/last_notified_version
          if git diff --cached --quiet; then
            exit 0
          fi
          branch="${GITHUB_REF#refs/heads/}"
          git commit -m "chore: update last notified version to ${TAG}"
          git push origin "HEAD:${branch}"
